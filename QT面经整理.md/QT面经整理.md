# QT面经整理

## 问题整理

### 一、信号与槽 和 元对象系统

#### 0、多线程参数传递

[QT多线程参数传递](https://blog.csdn.net/weixin_48503637/article/details/122466610)

#### 1、QT信号与槽机制？


Qt信号与槽的实现机理：在Qt中实现信号与槽最重要的就是通过元对象系统(MOS)的元对象编译器(MOC)将我们定义的需要使用到信号与槽的类中的信号及信号调用槽函数的方法进行定义（这一步就会生成与源文件对应的moc_xx.cpp文件），然后通过系统提供的关联方法(connect)将信号与槽建立一一对应关系，当发射信号（其实就是调用信号函数）时就会通过信号与槽的对应关系找到对应槽函数进行调用。


#### 2、QT信号与槽和回调相比

回调函数是函数指针的一种用法，如果多个类都关注某个类的状态变化，此时需要维护一个列表，以存放多个回调函数的地址。

在事件的处理方面，信号槽相比回调函数，具有类型安全、松耦合、任意参数的优势，但执行效率会有一点损失。

#### 3、QT的信号与槽，有哪几种连接方式，对应的应用场景是什么（第五个参数）

Qt :: ConnectionType type：connect的第五个参数
表示了信号与槽之间的关联方式：

* **Qt::AutoConnection**(自动连接)：信号的发送者与信号的接收者在同一线程，则默认使用Qt::DirectConnection；如果不在同一线程，则默认 使用Qt::QueuedConnection。

* **Qt::DirectConnection**(直接连接)：信号的发送者与信号的接收者在同一线程中执行，当发出信号后，会马上进入槽函数，看上去就像在信号发送位置调用了槽函数，在多线程下会比较危险，容易造成崩溃。**槽函数和信号发送者在同一线程**

* **Qt::QueuedConnection**(队列连接)：信号的发送者与信号的接收者不在同一线程中执行，槽函数运行于信号的接收者线程，当发送信号后，槽函数不会马上被调用，等待信号的接收者把当前函数执行完，进入事件循环之后，槽函数才会被调用。多线程环境下一般用这个。**槽函数与信号接受者在同一线程**

* **Qt::BlockingQueuedConnection**：槽函数的调用时机与Qt::QueuedConnection一致，不过发送完信号后**发送者所在线程会阻塞**，直到槽函数运行完。接收者和发送者绝对不能在一个线程，否则程序会死锁。在多线程间需要同步的场合可能需要这个。

* **Qt::UniqueConnection**：当某个信号和槽已经连接时，再进行重复的连接就会失败，**避免了重复连接**。



#### 4、信号与槽，是如何去提高它的匹配性能的，一个信号如何去高效的找它的槽函数





#### 5、QT信号与槽机制的优缺点

1）QT信号槽机制的引用精简了程序员的代码量 (不用写回调函数)

2）QT的信号可以对应多个槽（但他们的调用顺序随机），也可以多个槽映射一个信号 

3）QT的信号槽的建立和解除绑定十分自由 

4）信号槽同真正的回调函数比起来时间的耗损还是很大的，所有在嵌入式实时系统中应当慎用 

5）信号槽的参数限定很多例如不能携带模板类参数，不能出现宏定义等等


#### 6、对Qt元对象系统了解吧？

了解。
Qt对标准的C++进行了扩展，如信号槽、对象属性等。Qt的元对象编译系统MOC是一个预处理器，当Qt读取源文件时检测到类中包含有Q_OBJECT宏时，则会创建一个新的文件（生成路径下的moc开头的文件），将源码转换为C++编译器可以识别的代码写入moc开头的文件，然后C++编译器对其进行编译。当你的类需要使用Qt的扩展功能时，如信号槽、对象属性等时，则必须使用MOC，反之如果你的类不使用这些功能的时候不要无畏的使用MOC增大源码体积。使用MOC系统的方法：

    1. 继承QObject。

    2. 类中添加Q_OBJECT宏。   

#### 7、对Qt的信号槽机制了解吧？

号和槽是用于对象之间的通信的，是Qt的核心。为此Qt引入了一些关键字，他们是slots、signals、emit，这些都不是C++关键字，是Qt特有的，这些关键字会被Qt的moc转换为标准的C++语句。信号槽支持线程间通信，connect函数的第五个参数可以指定信号槽的连接方式：

1. Qt::AutoConnection：信号的发送者与信号的接收者在同一线程，则默认使用Qt::DirectConnection；如果不在同一线程，则默认  使用Qt::QueuedConnection。
2. Qt::DirectConnection：信号的发送者与信号的接收者在同一线程中执行，当发出信号后，会马上进入槽函数，看上去就像在信号  发送位置调用了槽函数，在多线程下会比较危险，容易造成崩溃。
3. Qt::QueuedConnection：信号的发送者与信号的接收者不在同一线程中执行，槽函数运行于信号的接收者线程，当发送信号后，  槽函数不会马上被调用，等待信号的接收者把当前函数执行完，进入事件循环之后，槽函数才会被调用。多线程环境下一般用这个。
4. Qt::BlockingQueuedConnection：槽函数的调用时机与Qt::QueuedConnection一致，不过发送完信号后发送者所在线程会阻塞，直到槽函数运行完。接收者和发送者绝对不能在一个线程，否则程序会死锁。在多线程间需要同步的场合可能需要这个。
5. Qt::UniqueConnection：可以通过按位或（|）与以上四个结合在一起使用。当设置此参数时，当某个信号和槽已经连接时，再进行重复的连接就会失败，也就是避免了重复连接。



#### 8、Qt中的MVD了解吧？

了解。Qt的MVD包含三个部分Model（模型），View（视图），代理（Delegate）。Model否则保存数据，View负责展示数据，Delegate负责Item样式绘制或处理输入。这三部分通过信号槽来进行通信，当Model中数据发生变化时将会发送信号到View，在View中编辑数据时，Delegate负责将编辑状态发送给Model层。基类分别为QAbstractItemModel、QAbstractItemView、QAbstractItemDelegate。Qt中提供了默认实现的MVD类，如QTableWidget、QListWidget、QTreeWidget等。




### 二、多线程

#### 1、描述QT下多线程的两种使用方法, 以及注意事项？

第一种方法:  QThread类，重写QThread类的run方法
1. 创建一个类从**QThread类派生** 
2. 在子线程类中重写 run 函数, 将处理操作写入该函数中 
3. 在主线程中创建子线程对象, 启动子线程, 调用start()函数 


优点：实现简单，可以用信号槽通信。

缺点：需要自己管理线程的创建释放，频繁地创建释放效率不高。所以适合常驻程序的线程使用。另外因为QThread对象属于父线程，所以对象中的槽函数（如果有的话）其实会在父线程执行。


第二种方法:   QThread类与**MoveToThread**，创建对象继承QObject，将对象移动到子线程对象

1. 将业务处理抽象成一个业务类, 在该类中创建一个业务处理函数 
2. 在主线程中创建一QThread类对象 
3. 在主线程中创建一个业务类对象 
4. 将业务类对象移动到子线程中 
5. 在主线程中启动子线程 
6. 通过信号槽的方式, 执行业务类中的业务处理函数 

优点：实现简单，使用于比较复杂的业务场景。

缺点：只能通过信号槽的方式调用业务对象的接口。且不能给此对象指定父对象。

**多线程使用注意事项: **
* 1. 业务对象, 构造的时候不能指定父对象 
* 2. 子线程中不能处理ui窗口(ui相关的类) 
* 3. 子线程中只能处理一些数据相关的操作, 不能涉及窗口


#### 2、知道死锁吗？死锁是如何产生的？
 

答：死锁的产生有如下四个必要条件

1.　资源是互斥的,同一时刻只能有一个进程占有该资源

2.　资源的释放只能有该进程自己完成

3.　线程在获取到需要资源之前,不会释放已有资源

4.　存在这么一条循环等待的队列,线程T1,T2,T3…, Tn

T1持有自己的资源请求T2的资源,….Tn持有自己的资源请求T1的资源


#### 3、线程同步的方法有哪些？

答：
1. 互斥量（QMutex）

       QMutex m_Mutex;        m_Mutex.lock();        m_Mutex.unlock();

2. 互斥锁（QMutexLocker）

        QMutexLocker mutexLocker(&m_Mutex);

        从声明处开始（在构造函数中加锁），出了作用域自动解锁（在析构函数中解锁）。

3. 等待条件（QWaitCondition）

QWaitCondtion m_WaitCondition; m_WaitConditon.wait(&m_muxtex, time);                 

m_WaitCondition.wakeAll();

4. QReadWriteLock类

》一个线程试图对一个加了读锁的互斥量进行上读锁，允许；

》一个线程试图对一个加了读锁的互斥量进行上写锁，阻塞；

》一个线程试图对一个加了写锁的互斥量进行上读锁，阻塞；、

》一个线程试图对一个加了写锁的互斥量进行上写锁，阻塞。

读写锁比较适用的情况是：需要多次对共享的数据进行读操作的阅读线程。

QReadWriterLock 与QMutex相似，除了它对 "read","write"访问进行区别对待。它使得多个读者可以共时访问数据。使用QReadWriteLock而不是QMutex，可以使得多线程程序更具有并发性。

5. 信号量QSemaphore

但是还有些互斥量（资源）的数量并不止一个，比如一个电脑安装了2个打印机，我已经申请了一个，但是我不能霸占这两个，你来访问的时候如果发现还有空闲的仍然可以申请到的。于是这个互斥量可以分为两部分，已使用和未使用。

6. QReadLocker便利类和QWriteLocker便利类对QReadWriteLock进行加解锁










### 三、网络


#### 1、描述Qt下Tcp通信的整个流程 

QT如果要进行网络编程首先需要在.pro中添加如下代码：QT += network 

**服务器端: **
1. 创建用于监听的套接字 
2. 给套接字设置监听 
3. 如果有连接到来, 监听的套接字会发出信号newConnected 
4. 接收连接, 通过nextPendingConnection()函数, 返回一个QTcpSocket类型的套接字对象(用于通信) 
5. 使用用于通信的套接字对象通信 
1>. 发送数据: write 
2>. 接收数据: readAll/read 

**客户端: **
1. 创建用于通信的套接字 
2. 连接服务器: connectToHost 
3. 连接成功与服务器通信 
1>. 发送数据: write 
2>. 接收数据: readAll/read

#### 2、描述QT下udp通信的整个流程


QT下udp通信服务器端和客户端的关系是对等的, 做的处理也是一样的. 
1. 创建套接字对象 
2. 如果需要接收数据, 必须绑定端口 
3. 发送数据: writeDatagram 
4. 接收数据: readDatagram 

#### 3、HTTP协议有使用过吗？QT5中使用的相关联的主要的几个类？

QNetworkAccessManager/QNetworkRequest/QNetworkReply



### 四、窗口


#### 1、QMainForm是从哪里派生的？

QMainWindow::QWidget::QObject

#### 2、Qwidget、Qobejct实现了哪些功能

**QObject**

1、信号和槽的非常强大的机制,使用connect()把信号和槽连接起来并且可以用disconnect()来破坏这种连接。为了避免从不结束的通知循环，你可以调用blockSignals()临时地阻塞信号。保护函数connectNotify()和disconnectNotify()使跟踪连接成为可能。

2、QObject可以通过event()接收事件并且过滤其它对象的事件。详细情况请参考installEventFilter()和eventFilter()。一个方便的处理者，childEvent()，能够被重新实现来捕获子对象事件。

3、最后但不是最不重要的一点，QObject提供了Qt中最基本的定时器，关于定时器的高级支持请参考QTimer。

4、注意Q_OBJECT宏对于任何实现信号、槽和属性的对象都是强制的。

5、所有的Qt窗口部件继承了QObject。方便的函数isWidgetType()返回这个对象实际上是不是一个窗口部件。它比inherits(“QWidget” )快得多。

**QWidget**

1、QWidget类是所有用户界面对象的基类。
2、Widget是用户界面的基本单元：它从窗口系统接收鼠标，键盘和其他事件，并在屏幕上绘制自己。每个Widget都是矩形的，它们按照Z-order进行排序。







### 其他

#### 1、为什么要用qt来做界面

Qt的跨平台性很强，比如同样一套代码写好pro文件可以在windows/linux/Android等直接编译。


#### 2、描述QT中的文件流(QTextStream)和数据流(QDataStream)的区别, 他们都能帮助我们完成一些什么事情. 

* QTextStream – 文本流, 操作轻量级数据(int, double, QString), 数据写入文件中之后以文本的方式呈现。 
* QDataStream – 数据流, 通过数据流可以操作各种数据类型, 包括类对象, 存储到文件中数据可以还原到内存。 

QTextStream, QDataStream可以操作磁盘文件, 也可以操作内存数据, 通过流对象可以将数据打包到内存, 进行数据的传输.


#### 3、自定义控件：应该做过吧？能举几个例子吗？还有其他的吗？

从外观设计上：QSS、继承绘制函数重绘、继承QStyle相关类重绘、组合拼装等等

从功能行为上：重写事件函数、添加或者修改信号和槽等等


#### 4、QSS: QSS平时使用的多吗？能举几个例子吗？都是如何使用，能说说吗？

1.将QSS统一写在一个文件中，通过程序给主窗口加载；

2.写成一个字符串中，通过程序给主窗口加载；

3.需要使用的地方，写一个字符串，加载给对象；

4.QT Designer中填写；


#### 5、事件机制：QT程序是事件驱动的，事件到处都可以遇到。能说说平时经常使用到哪些事件吗？

常见的QT事件类型如下:

键盘事件: 按键按下和松开    鼠标事件: 鼠标移动,鼠标按键的按下和松开

拖放事件: 用鼠标进行拖放    滚轮事件: 鼠标滚轮滚动

绘屏事件: 重绘屏幕的某些部分    定时事件: 定时器到时

焦点事件: 键盘焦点移动   进入和离开事件: 鼠标移入widget之内,或是移出

移动事件: widget的位置改变    大小改变事件: widget的大小改变

显示和隐藏事件: widget显示和隐藏    窗口事件: 窗口是否为当前窗口



#### 6、知道QT事件机制有几种级别的事件过滤吗？能大致描述下吗？
 
根据对Qt事件机制的分析, 我们可以得到5种级别的事件过滤,处理办法. 以功能从弱到强, 排列如下:

1）**重载特定事件处理函数.**

最常见的事件处理办法就是重载象mousePressEvent(), keyPressEvent(), paintEvent() 这样的特定事件处理函数.

2）**重载event()函数.**

通过重载event()函数,我们可以在事件被特定的事件处理函数处理之前(像keyPressEvent())处理它. 比如, 当我们想改变tab键的默认动作时,一般要重载这个函数. 在处理一些不常见的事件(比如:LayoutDirectionChange)时,evnet()也很有用,因为这些函数没有相应的特定事件处理函数. 当我们重载event()函数时, 需要调用父类的event()函数来处理我们不需要处理或是不清楚如何处理的事件.

3） 在Qt对象上安装事件过滤器.

安装事件过滤器有两个步骤: (假设要用A来监视过滤B的事件)

首先调用B的installEventFilter( const QOject *obj ), 以A的指针作为参数. 这样所有发往B的事件都将先由A的eventFilter()处理.

然后, A要重载QObject::eventFilter()函数, 在eventFilter() 中书写对事件进行处理的代码.

4） 给QAppliction对象安装事件过滤器.

一旦我们给qApp(每个程序中唯一的QApplication对象)装上过滤器,那么所有的事件在发往任何其他的过滤器时,都要先经过当前这个 eventFilter(). 在debug的时候,这个办法就非常有用, 也常常被用来处理失效了的widget的鼠标事件,通常这些事件会被QApplication::notify()丢掉. ( 在QApplication::notify() 中, 是先调用qApp的过滤器, 再对事件进行分析, 以决定是否合并或丢弃)

5） 继承QApplication类, 并重载notify()函数.

Qt 是用QApplication::notify()函数来分发事件的.想要在任何事件过滤器查看任何事件之前先得到这些事件,重载这个函数是唯一的办法. 通常来说事件过滤器更好用一些, 因为不需要去继承QApplication类. 而且可以给QApplication对象安装任意个数的事件。



#### 7、QT版本：QT5\QT6

Qt6对比Qt5都有哪些变化呢？

1. **支持C++17**。Qt的发展要跟上C++的发展，C++17由2017年底发布，C++20也也已经发布，Qt6的发布终于能用上C++17了。
2. **新一代的QML**。由于我不是做QML开发的，对QML不太了解，根据官方文档，看起来变化挺大。
3. **新的图形架构**。Linux上OpenGL的指定继承者Vulkan，Apple正在推动的Metal等图像接口的发展，Qt5依赖OpenGL已经不够用，现在，Qt 6 加入了大量不同平台的图形 API，以确保用户可以在所有平台上以最高性能运行 Qt。
4. **改用 CMake 构建系统**。Qt 6 本身现在是使用CMake构建的。这也为使用 CMake 构建项目的所有用户带来了体验优化。当然为了和兼容Qt5等，Qt6也将继续支持qmake。
5. **Qt Quick 统一 2D 和 3D**。整合2D和3D内容到一个技术栈上。


#### 8、工作中有没有使用过动态库和静态库？能不能简单说下两者的区别？

**静态库**：在链接阶段将汇编生成的目标文件.o与引用库一起链接打包到可执行文件中，可简单看成（.o或者.obj文件的集合）。（1）对函数库的链接是放在编译时期完成的（2）程序在运行时与函数库没有瓜葛，移植方便（3）浪费空间和资源

**动态库**：（1）将库函数的链接载入推迟到程序运行时期（2）可以实现进程间的资源共享（因此也称为共享库）（3）将一些程序升级变得简单（4）可以真正的做到链接载入完全由程序员在程序代码中控制（显示调用）

#### 9、动态库一般也会有个lib文件，那么和静态库lib文件有什么区别？

动态库中的.lib文件叫做导入库，对于导入库而言，其实际的执行代码位于dll动态库中，导入库只包含了地址符号表等，确保程序找到对应函数的一些基本地址信息。

静态库中的.lib叫做静态库，本身就包含了实际执行代码、符号表等等


## 面经参考
### 字节跳动客户端

#### 1、

[字节跳动客户端1](https://leetcode.cn/circle/discuss/f27hW1/)


![](vx_images/549433421245190.png)

#### 2、


参考：

[面经：字节跳动客户端2](https://www.nowcoder.com/discuss/834874?type=all&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_all_nctrack)
![](vx_images/507014521226431.png)



